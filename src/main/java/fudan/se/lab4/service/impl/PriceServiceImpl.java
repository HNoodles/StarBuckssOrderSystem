package fudan.se.lab4.service.impl;

import fudan.se.lab4.entity.Drink;

import fudan.se.lab4.service.PriceService;
import fudan.se.lab4.strategy.Strategy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PriceServiceImpl implements PriceService {
    /**
     * This method should use the parameter list of drinks as source,
     * and then calculate the total price of the drinks.
     * Finally, it should return the total price to order service
     *
     * @param drinks list of drinks generated by product service
     * @return total price
     */
    @Override
    public double getPriceByDrinks(List<Drink> drinks) {
        double originPrice = 0;

        for (Drink drink : drinks) {
            originPrice += drink.cost();
        }

        return Math.round(originPrice * 100) / 100.0;
    }

    /**
     * compute the discount
     *
     * @param drinks      list of input drinks
     * @param msgs        a list used to store the message of discount
     * @param originPrice the total price of drinks without discount
     * @return the discounted price
     */
    @Override
    public double getDiscountByOrder(List<Drink> drinks, List<String> msgs, List<String> logMsgs, double originPrice, List<Strategy> strategies, String pattern) {
        double discount = 0;

        Map<String, List<Strategy>> map = getClassifiedStrategies(strategies);
        Map.Entry<String, List<Strategy>> usedEntry = null;

        for (Map.Entry<String, List<Strategy>> entry : map.entrySet()) {
            double discountTmp = 0;

            for (Strategy strategy : entry.getValue()) {
                discountTmp += strategy.cost(drinks, originPrice, pattern);
            }

            if (discountTmp > discount) {
                discount = discountTmp;
                usedEntry = entry;
            }
        }

        if (usedEntry != null) {
            for (Strategy strategy : usedEntry.getValue()) {
                msgs.addAll(strategy.getMsgs());
                logMsgs.addAll(strategy.getLogMsgs());
            }
        }

        return discount;   // already rounded
    }

    // classify strategies into mutually exclusive classifications
    public Map<String, List<Strategy>> getClassifiedStrategies(List<Strategy> strategies) {
        Map<String, List<Strategy>> map = new HashMap<>();

        for (Strategy strategy : strategies) {
            if (map.containsKey(strategy.getType())) {
                map.get(strategy.getType()).add(strategy);
            } else {
                ArrayList<Strategy> list = new ArrayList<>();
                list.add(strategy);
                map.put(strategy.getType(), list);
            }
        }

        return map;
    }

}